一主二从还可以，但是一主6仆主机会受不了。
因为他每次都要把命令发给从机，这样的并联模式给
主机的压力太大：
主机-->从1
    -->从2
    -->从n
改为串联模式：
主机-->从1-->从2-->从n

从机6381:
slaveof 127.0.0.1 6380 设置为串联

但是这也有问题，如果6380宕机，那么6381也完了。

*较大的项目会综合串联和并联的优势，搭建一个树形结构。

串联也好并联也好，主机宕机，从机会死等。
这样怎么办？
让从机升级为主机
主机:
shutdown
从机:
slaveof no one
info replication
这就是反客为主

这样也是有问题的，因为要手动的反客为主。
这个时候哨兵出现了，监控主机，当主机宕机，自动设置一个
从机为主机。
这里监控主机就是不断的去ping主机

哨兵sentinal
配置哨兵
自定义的/myredis目录下新建sentinel.conf文件
再配置文件里填写内容
哨兵	 监控	 自定义	   ip	    port 
sentinel monitor mymaster 127.0.0.1 6379 1

mymaster为监控对象起的服务器的名称，1为至少
有多少个哨兵同一迁移的数量。（投票）

单独一个shell窗口

开启哨兵

redis-sentinel sentinel.conf

主机宕机，反应时间有个延迟。

这个时候从机6381变成主机，
因为6381的优先级高。
slave-priority 10 从机的优先级，数值越小，优先级越高

主机：
重新开启
他已经不是主机了，而是从机。

故障恢复：

--新主登基
从下线的主机服务的所有服务中挑选一个从服务，将其转成
主服务。
选择条件依次是：
1、优先级最高
2、偏移量最大
3、runid最小

偏移量是主机宕机的一刻有可能还给某个从机发送了数据，这个
时候两个从机与主机的偏移量就不同了（偏移量不是差值）
可以通俗的理解为获得原主数据最多的。

runid是redis随机产生的40位进程号。
查看runid：info

--群仆俯首
挑选出新的主服务之后，sentinel向原来的主服务的从服务发送
slaveof新主服务的命令，复制新的master

--旧主俯首
宕机的旧主服务重新上线，sentinel会向其发送slaveof命令，让
它成为新主的从服务。
















